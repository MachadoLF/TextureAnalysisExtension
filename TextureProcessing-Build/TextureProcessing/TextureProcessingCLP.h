// This file was automatically generated by:
//  /usr/local/Slicer/SlicerExecutionModel-build/GenerateCLP/bin/GenerateCLP --InputXML /home/leonardo/Desktop/Modulos-Source/Modulos_to_Slicer/TextureProcessingExtension/TextureProcessing/TextureProcessing.xml --OutputCxx /home/leonardo/Desktop/Modulos-Source/Modulos_to_Slicer/TextureProcessingExtension/TextureProcessing-Build/TextureProcessing/TextureProcessingCLP.h
//
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <map>

#include <sstream>
#include <fstream>
#include <stdexcept>

#include "tclap/CmdLine.h"
#include "JsonSerializationUtilities.h"
#include "ModuleProcessInformation.h"

#ifdef _WIN32
#define Module_EXPORT __declspec(dllexport)
#elif defined(MODULE_HIDDEN_VISIBILITY)
#define Module_EXPORT __attribute__((visibility("default")))
#else
#define Module_EXPORT
#endif


extern "C" {
Module_EXPORT char JSONModuleDescription[] =
"{\n"
"	\"Category\" : \"Texture Analysis\",\n"
"	\"Contributor\" : \"Leonardo Machado\",\n"
"	\"Description\" : \"This is a CLI module to extract Textural Information of a MRI region of interest defined by a label region.\",\n"
"	\"DocumentationURL\" : \"http://www.example.com/Slicer/Modules/HistogramStatistics\",\n"
"	\"License\" : \"Slicer\",\n"
"	\"ParameterGroups\" : \n"
"	[\n"
"		{\n"
"			\"Description\" : \"Input/output parameters\",\n"
"			\"Label\" : \"IO\",\n"
"			\"Parameters\" : \n"
"			[\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Input volume\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"0\",\n"
"					\"Label\" : \"Input Volume\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"inputVolume\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"image\",\n"
"					\"Value\" : \"\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Input Label\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"1\",\n"
"					\"Label\" : \"Input Label\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"inputLabel\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"image\",\n"
"					\"Value\" : \"\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Where do you wan to save tour data files?\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Saving path\",\n"
"					\"LongFlag\" : \"spath\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"spath\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"directory\",\n"
"					\"Value\" : \"\"\n"
"				}\n"
"			]\n"
"		},\n"
"		{\n"
"			\"Description\" : \"Features to be extracted\",\n"
"			\"Label\" : \"Cheking Features\",\n"
"			\"Parameters\" : \n"
"			[\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to do a normalization of pixel intensities in the image before feature extraction.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"n\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Normalization\",\n"
"					\"LongFlag\" : \"donormalization\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doNormalization\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to extract histogram features.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"d\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Histogram Features\",\n"
"					\"LongFlag\" : \"dohistogramfeat\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doHistogramFeat\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to calculate and save percentile values.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"p\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Percentiles\",\n"
"					\"LongFlag\" : \"dopercentiles\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doPercentiles\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to extract coocurrence matrix features.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"c\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Coocurrence Matrix Features\",\n"
"					\"LongFlag\" : \"docoocurrencefeat\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doCoocurrenceFeat\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to extract run length matrix features.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"r\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Run Lengh Matrix Features\",\n"
"					\"LongFlag\" : \"dorunfeat\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doRunFeat\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to extract gradient features.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"g\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Gradient Features\",\n"
"					\"LongFlag\" : \"dogradient\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doGradient\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"Allows it to extract shape features.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"s\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Shape Features\",\n"
"					\"LongFlag\" : \"doshapefeat\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doShapeFeat\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Description\" : \"This will plot the histogram in a .txt file.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"t\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Plot Histogram\",\n"
"					\"LongFlag\" : \"dohistoplot\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"doHistoPlot\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\",\n"
"					\"Value\" : \"true\"\n"
"				}\n"
"			]\n"
"		}\n"
"	],\n"
"	\"Title\" : \"Texture Extractor\",\n"
"	\"Version\" : \"1.0\"\n"
"}\n"
"\n"
;
}
#define GENERATE_DESERIALIZATION \
    if (argc >= 2) \
      { \
      for (int arg_idx = 0; arg_idx < argc; ++arg_idx) \
        { \
        if (strcmp(argv[arg_idx],"--deserialize") == 0) \
          { \
          std::ifstream fStream( argv[arg_idx+1] ); \
          if( !fStream.is_open() ) \
            { \
            std::cerr << "Could not open file: " << argv[arg_idx+1] << " for writing." << std::endl; \
            return EXIT_FAILURE; \
            } \
          Json::Value root; \
          Json::Reader reader; \
          reader.parse( fStream, root ); \
          const Json::Value & parameters = root["Parameters"]; \
          if (!parameters["IO"]["inputVolume"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["inputVolume"].asString()); \
            } \
          if (!parameters["IO"]["inputLabel"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["inputLabel"].asString()); \
            } \
          if (!parameters["IO"]["spath"].isNull()) \
            { \
            Json::Value param = parameters["IO"]["spath"]; \
            if (!param.isArray()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--spath"); \
              deserializedVectorFlaggedArgs.push_back(param.asString()); \
              } \
            else if(param.size() > 0) \
              { \
              std::string value = ""; \
              for (unsigned int i = 0; i < param.size(); ++i) \
                { \
                value += param[i].asString(); \
                if (i < param.size() - 1) \
                  { \
                  value += ", "; \
                  } \
                } \
              deserializedVectorFlaggedArgs.push_back("--spath"); \
              deserializedVectorFlaggedArgs.push_back(value); \
              } \
            } \
          if (!parameters["Cheking Features"]["doNormalization"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doNormalization"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--donormalization"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doHistogramFeat"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doHistogramFeat"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--dohistogramfeat"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doPercentiles"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doPercentiles"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--dopercentiles"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doCoocurrenceFeat"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doCoocurrenceFeat"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--docoocurrencefeat"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doRunFeat"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doRunFeat"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--dorunfeat"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doGradient"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doGradient"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--dogradient"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doShapeFeat"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doShapeFeat"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--doshapefeat"); \
              } \
            } \
          if (!parameters["Cheking Features"]["doHistoPlot"].isNull()) \
            { \
            if (parameters["Cheking Features"]["doHistoPlot"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--dohistoplot"); \
              } \
            } \
          } \
        } \
      }
#define GENERATE_SERIALIZATION \
    if( parametersSerializeArg.isSet() ) \
      { \
      Json::Value root; \
      Json::Value & parameters = root["Parameters"]; \
        { \
        Json::Value & parameterGroup = parameters["IO"]; \
        parameterGroup["inputVolume"] = JsonSerialize( inputVolume ); \
        parameterGroup["inputLabel"] = JsonSerialize( inputLabel ); \
        parameterGroup["spath"] = JsonSerialize( spath ); \
        } \
        { \
        Json::Value & parameterGroup = parameters["Cheking Features"]; \
        parameterGroup["doNormalization"] = JsonSerialize( doNormalization ); \
        parameterGroup["doHistogramFeat"] = JsonSerialize( doHistogramFeat ); \
        parameterGroup["doPercentiles"] = JsonSerialize( doPercentiles ); \
        parameterGroup["doCoocurrenceFeat"] = JsonSerialize( doCoocurrenceFeat ); \
        parameterGroup["doRunFeat"] = JsonSerialize( doRunFeat ); \
        parameterGroup["doGradient"] = JsonSerialize( doGradient ); \
        parameterGroup["doShapeFeat"] = JsonSerialize( doShapeFeat ); \
        parameterGroup["doHistoPlot"] = JsonSerialize( doHistoPlot ); \
        } \
      std::ofstream fStream( parametersSerializeArg.getValue().c_str() ); \
      if( !fStream.is_open() ) \
        { \
        std::cerr << "Could not open file: " << parametersSerializeArg.getValue() << " for writing." << std::endl; \
        return EXIT_FAILURE; \
        } \
      Json::StyledStreamWriter writer; \
      writer.write( fStream, root ); \
      fStream.close(); \
      }
#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>Texture Analysis</category>\n"
"  <title>Texture Extractor</title>\n"
"  <description><![CDATA[This is a CLI module to extract Textural Information of a MRI region of interest defined by a label region.]]></description>\n"
"  <version>1.0</version>\n"
"  <documentation-url>http://www.example.com/Slicer/Modules/HistogramStatistics</documentation-url>\n"
"  <license>Slicer</license>\n"
"  <contributor>Leonardo Machado</contributor>\n"
"  <acknowledgements>This work is part of the required work for Master's Dissertation Defense. This CLI module was developed in the Computing in Signals and Images in Medicine Laboratory, at University of São Paulo, Ribeirão Preto, CSIM. Addional credits and special thanks to Luiz Otavio Murta Junior, Fabrício Simozo, Antonio Carlos Senra Filho, Gustavo Barizon, Mehran Azimbagirad, who gave valuable contributions and improvements to this work.</acknowledgements>\n"
"  <parameters>\n"
"   <label>IO</label>\n"
"   <description><![CDATA[Input/output parameters]]></description>\n"
"   <image>\n"
"    <name>inputVolume</name>\n"
"    <label>Input Volume</label>\n"
"    <channel>input</channel>\n"
"    <index>0</index>\n"
"    <description><![CDATA[Input volume]]></description>\n"
"   </image>\n"
"   <image>\n"
"    <name>inputLabel</name>\n"
"    <label>Input Label</label>\n"
"    <channel>input</channel>\n"
"    <index>1</index>\n"
"    <description><![CDATA[Input Label]]></description>\n"
"   </image>\n"
"   <directory>\n"
"    <label>Saving path</label>\n"
"    <name>spath</name>\n"
"    <longflag>--spath</longflag>\n"
"    <description><![CDATA[Where do you wan to save tour data files?]]></description>\n"
"   </directory>\n"
"  </parameters>\n"
"  <parameters>\n"
"   <label>Cheking Features</label>\n"
"   <description><![CDATA[Features to be extracted]]></description>\n"
"   <boolean>\n"
"    <name>doNormalization</name>\n"
"    <flag>-n</flag>\n"
"    <longflag>--donormalization</longflag>\n"
"    <label>Normalization</label>\n"
"    <description><![CDATA[Allows it to do a normalization of pixel intensities in the image before feature extraction.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doHistogramFeat</name>\n"
"    <flag>-d</flag>\n"
"    <longflag>--dohistogramfeat</longflag>\n"
"    <label>Histogram Features</label>\n"
"    <description><![CDATA[Allows it to extract histogram features.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doPercentiles</name>\n"
"    <flag>-p</flag>\n"
"    <longflag>--dopercentiles</longflag>\n"
"    <label>Percentiles</label>\n"
"    <description><![CDATA[Allows it to calculate and save percentile values.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doCoocurrenceFeat</name>\n"
"    <flag>-c</flag>\n"
"    <longflag>--docoocurrencefeat</longflag>\n"
"    <label>Coocurrence Matrix Features</label>\n"
"    <description><![CDATA[Allows it to extract coocurrence matrix features.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doRunFeat</name>\n"
"    <flag>-r</flag>\n"
"    <longflag>--dorunfeat</longflag>\n"
"    <label>Run Lengh Matrix Features</label>\n"
"    <description><![CDATA[Allows it to extract run length matrix features.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doGradient</name>\n"
"    <flag>-g</flag>\n"
"    <longflag>--dogradient</longflag>\n"
"    <label>Gradient Features</label>\n"
"    <description><![CDATA[Allows it to extract gradient features.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doShapeFeat</name>\n"
"    <flag>-s</flag>\n"
"    <longflag>--doshapefeat</longflag>\n"
"    <label>Shape Features</label>\n"
"    <description><![CDATA[Allows it to extract shape features.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"   <boolean>\n"
"    <name>doHistoPlot</name>\n"
"    <flag>-t</flag>\n"
"    <longflag>--dohistoplot</longflag>\n"
"    <label>Plot Histogram</label>\n"
"    <description><![CDATA[This will plot the histogram in a .txt file.]]></description>\n"
"    <default>true</default>\n"
"   </boolean>\n"
"  </parameters>\n"
"</executable>\n"
"\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_DECLARE \
    /* These two vectors are used to store the JSON deserialized value */ \
    /* that are then compiled with the command line. */ \
    std::vector< std::string > deserializedVectorFlaggedArgs; \
    std::vector< std::string > deserializedVectorPositionalArgs; \
    /* This map is used to store the JSON deserialized value of multiple args*/ \
    /* where the key is the argument flag and the value the values of each arg. */ \
    std::map< std::string, std::vector<std::string> > deserializedMultipleArgsMap; \
 \
    /* This vector is used to look up if a flag requires an argument after it. */ \
    /* This is used to differentiate between: */ \
    /* ./myExec --boolFlag /my/first/arg */ \
    /* ./myExec --flag flagArg */ \
    std::vector< std::string > nonbooleanFlags; \
    nonbooleanFlags.push_back("--spath"); \
    nonbooleanFlags.push_back("--serialize"); \
    nonbooleanFlags.push_back("--deserialize"); \
    nonbooleanFlags.push_back("--processinformationaddress"); \
    nonbooleanFlags.push_back("--returnparameterfile"); \
    /* This map use is twofold: */ \
    /*  - to find whether a flag is multiple */ \
    /*  - to know if we need to reset the multiple arg value because it was */ \
    /*    in the JSON and it's also in the command line. */ \
    std::map<std::string, bool> multipleFlags; \
    std::string inputVolume; \
    std::string inputLabel; \
    std::string spath; \
    bool doNormalization = false; \
    bool doHistogramFeat = false; \
    bool doPercentiles = false; \
    bool doCoocurrenceFeat = false; \
    bool doRunFeat = false; \
    bool doGradient = false; \
    bool doShapeFeat = false; \
    bool doHistoPlot = false; \
    std::string parametersSerialize; \
    std::string parametersDeSerialize; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \

#define GENERATE_TCLAP_PARSE \
    std::string fullDescription("Description: "); \
    fullDescription += "This is a CLI module to extract Textural Information of a MRI region of interest defined by a label region."; \
    if (!std::string("Leonardo Machado").empty()) \
      { \
      fullDescription += "\nAuthor(s): Leonardo Machado"; \
      } \
    if (!std::string("This work is part of the required work for Master's Dissertation Defense. This CLI module was developed in the Computing in Signals and Images in Medicine Laboratory, at University of São Paulo, Ribeirão Preto, CSIM. Addional credits and special thanks to Luiz Otavio Murta Junior, Fabrício Simozo, Antonio Carlos Senra Filho, Gustavo Barizon, Mehran Azimbagirad, who gave valuable contributions and improvements to this work.").empty()) \
      { \
      fullDescription += "\nAcknowledgements: This work is part of the required work for Master's Dissertation Defense. This CLI module was developed in the Computing in Signals and Images in Medicine Laboratory, at University of São Paulo, Ribeirão Preto, CSIM. Addional credits and special thanks to Luiz Otavio Murta Junior, Fabrício Simozo, Antonio Carlos Senra Filho, Gustavo Barizon, Mehran Azimbagirad, who gave valuable contributions and improvements to this work."; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "1.0" ); \
 \
      std::ostringstream msg; \
    msg.str("");msg << "Input volume";    TCLAP::UnlabeledValueArg<std::string> inputVolumeArg("inputVolume", msg.str(), 1, inputVolume, "std::string", commandLine); \
 \
    msg.str("");msg << "Input Label";    TCLAP::UnlabeledValueArg<std::string> inputLabelArg("inputLabel", msg.str(), 1, inputLabel, "std::string", commandLine); \
 \
    msg.str("");msg << "Where do you wan to save tour data files?";    TCLAP::ValueArg<std::string > spathArg("", "spath", msg.str(), 0, spath, "std::string", commandLine); \
 \
    msg.str("");msg << "Allows it to do a normalization of pixel intensities in the image before feature extraction. (value: " << doNormalization << ")"; \
    TCLAP::SwitchArg doNormalizationArg("n", "donormalization", msg.str(), commandLine, doNormalization); \
 \
    msg.str("");msg << "Allows it to extract histogram features. (value: " << doHistogramFeat << ")"; \
    TCLAP::SwitchArg doHistogramFeatArg("d", "dohistogramfeat", msg.str(), commandLine, doHistogramFeat); \
 \
    msg.str("");msg << "Allows it to calculate and save percentile values. (value: " << doPercentiles << ")"; \
    TCLAP::SwitchArg doPercentilesArg("p", "dopercentiles", msg.str(), commandLine, doPercentiles); \
 \
    msg.str("");msg << "Allows it to extract coocurrence matrix features. (value: " << doCoocurrenceFeat << ")"; \
    TCLAP::SwitchArg doCoocurrenceFeatArg("c", "docoocurrencefeat", msg.str(), commandLine, doCoocurrenceFeat); \
 \
    msg.str("");msg << "Allows it to extract run length matrix features. (value: " << doRunFeat << ")"; \
    TCLAP::SwitchArg doRunFeatArg("r", "dorunfeat", msg.str(), commandLine, doRunFeat); \
 \
    msg.str("");msg << "Allows it to extract gradient features. (value: " << doGradient << ")"; \
    TCLAP::SwitchArg doGradientArg("g", "dogradient", msg.str(), commandLine, doGradient); \
 \
    msg.str("");msg << "Allows it to extract shape features. (value: " << doShapeFeat << ")"; \
    TCLAP::SwitchArg doShapeFeatArg("s", "doshapefeat", msg.str(), commandLine, doShapeFeat); \
 \
    msg.str("");msg << "This will plot the histogram in a .txt file. (value: " << doHistoPlot << ")"; \
    TCLAP::SwitchArg doHistoPlotArg("t", "dohistoplot", msg.str(), commandLine, doHistoPlot); \
 \
    msg.str("");msg << "Store the module's parameters to a file.";    TCLAP::ValueArg<std::string > parametersSerializeArg("", "serialize", msg.str(), 0, parametersSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Restore the module's parameters that were previously archived.";    TCLAP::ValueArg<std::string > parametersDeSerializeArg("", "deserialize", msg.str(), 0, parametersDeSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (value: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (value: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (value: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
 \
    /* Go through argc and consolidate the JSON with the parameters from the command line */ \
    /* In case of conflict, take the command line. */ \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    std::vector<std::string>::iterator dvOptionnalArgsIt = deserializedVectorFlaggedArgs.begin(); \
    std::map<std::string, std::vector<std::string> >::iterator dvMultipleArgsIt; \
    size_t noFlagCounter = 0; \
    size_t ac = 1; \
 \
    while (ac < static_cast<size_t>(argc)) \
      { \
      /* short flag case && long flag case */ \
       if ((strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
           || (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-')) \
         { \
         std::string flag = argv[ac]; \
         /* Remap the flag if necessary */ \
         if (strlen(argv[ac]) == 2) \
           { \
           /* Short flag remapping */ \
           ait = flagAliasMap.find(flag); \
           dait = deprecatedFlagAliasMap.find(flag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << flag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         else \
           { \
           /* Long flag remapping */ \
           ait = longFlagAliasMap.find(flag); \
           dait = deprecatedLongFlagAliasMap.find(flag); \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << flag << "\" is deprecated. Please use long flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         bool isMultiple = multipleFlags.find(flag) != multipleFlags.end(); \
         bool isBoolean = std::find(nonbooleanFlags.begin(), nonbooleanFlags.end(), flag) == nonbooleanFlags.end(); \
         dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), flag); \
         bool isPresentVFA = dvOptionnalArgsIt != deserializedVectorFlaggedArgs.end(); \
         if (isBoolean) \
           { \
           /*Ignore if boolean and already present*/ \
           /*Otherwise add it*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           } \
         else if (isMultiple) \
           { \
           dvMultipleArgsIt = deserializedMultipleArgsMap.find(flag); \
           bool isPresentMA = dvMultipleArgsIt != deserializedMultipleArgsMap.end(); \
           /*Ignore if boolean and already present*/ \
           /*Reset/Add the value if first deserialize or not present*/ \
           if (!isPresentMA || !multipleFlags[flag]) \
             { \
             deserializedMultipleArgsMap[flag] = std::vector<std::string>(); \
             multipleFlags[flag] = true; \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           deserializedMultipleArgsMap[flag].push_back(value); \
           } \
         else \
           { \
           /*Add the flag and if needed*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(value);  \
             } \
           else \
             { \
             *(++dvOptionnalArgsIt) = value; \
             } \
           } \
         } \
       /* short flag case where multiple flags are given at once */ \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         std::string rflag(argv[ac], 1, std::string::npos); \
         for (std::string::size_type fi=0; fi < rflag.size(); ++fi) \
           { \
           std::string tf(rflag, fi, 1); \
           std::string newFlag ="-"; \
           newFlag += tf; \
           ait = flagAliasMap.find(newFlag); \
           dait = deprecatedFlagAliasMap.find(newFlag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             newFlag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << newFlag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             newFlag = (*dait).second; \
             } \
           dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), newFlag); \
           /*These flags are always boolean, just add it if it's not there already */ \
           if (dvOptionnalArgsIt == deserializedVectorFlaggedArgs.end()) \
             { \
             deserializedVectorFlaggedArgs.push_back(newFlag); \
             } \
           } \
         ++ac; \
         } \
       else \
         { \
         /* Replace if needed, otherwise append.*/ \
         if (noFlagCounter < deserializedVectorPositionalArgs.size()) \
           { \
           deserializedVectorPositionalArgs[noFlagCounter] = argv[ac]; \
           } \
         else \
           { \
           deserializedVectorPositionalArgs.push_back(argv[ac]); \
           } \
         ++ac; \
         ++noFlagCounter; \
         } \
       } \
 \
    /* Put the now compiled arguments in the argvVector */ \
    std::vector<std::string> argvVector; \
    argvVector.push_back(argv[0]); \
    argvVector.insert(argvVector.end(), deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end()); \
    std::map<std::string, std::vector<std::string> >::iterator mavit; \
    for (mavit = deserializedMultipleArgsMap.begin(); mavit != deserializedMultipleArgsMap.end(); ++mavit) \
      { \
      for (size_t i = 0; i < mavit->second.size(); ++i) \
        { \
        argvVector.push_back(mavit->first); \
        argvVector.push_back(mavit->second.at(i)); \
        } \
      } \
    argvVector.insert(argvVector.end(), deserializedVectorPositionalArgs.begin(), deserializedVectorPositionalArgs.end()); \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < argvVector.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(argvVector[ac].c_str())); \
     } \
    commandLine.parse ( static_cast<int>(vargs.size()), (char**) &(vargs[0]) ); \
  } \
catch ( TCLAP::ArgException & e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_TCLAP_ASSIGNMENT \
      inputVolume = inputVolumeArg.getValue(); \
      inputLabel = inputLabelArg.getValue(); \
      spath = spathArg.getValue(); \
      doNormalization = doNormalizationArg.getValue(); \
      doHistogramFeat = doHistogramFeatArg.getValue(); \
      doPercentiles = doPercentilesArg.getValue(); \
      doCoocurrenceFeat = doCoocurrenceFeatArg.getValue(); \
      doRunFeat = doRunFeatArg.getValue(); \
      doGradient = doGradientArg.getValue(); \
      doShapeFeat = doShapeFeatArg.getValue(); \
      doHistoPlot = doHistoPlotArg.getValue(); \
      parametersSerialize = parametersSerializeArg.getValue(); \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      echoSwitch = echoSwitchArg.getValue(); \
      xmlSwitch = xmlSwitchArg.getValue(); \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      returnParameterFile = returnParameterFileArg.getValue(); \

#define GENERATE_TCLAP GENERATE_TCLAP_PARSE;GENERATE_TCLAP_ASSIGNMENT
#define GENERATE_TCLAP_ASSIGNMENT_IFSET \
    if( inputVolumeArg.isSet() ) \
      { \
      inputVolume = inputVolumeArg.getValue(); \
      } \
    if( inputLabelArg.isSet() ) \
      { \
      inputLabel = inputLabelArg.getValue(); \
      } \
    if( spathArg.isSet() ) \
      { \
      spath = spathArg.getValue(); \
      } \
    if( doNormalizationArg.isSet() ) \
      { \
      doNormalization = doNormalizationArg.getValue(); \
      } \
    if( doHistogramFeatArg.isSet() ) \
      { \
      doHistogramFeat = doHistogramFeatArg.getValue(); \
      } \
    if( doPercentilesArg.isSet() ) \
      { \
      doPercentiles = doPercentilesArg.getValue(); \
      } \
    if( doCoocurrenceFeatArg.isSet() ) \
      { \
      doCoocurrenceFeat = doCoocurrenceFeatArg.getValue(); \
      } \
    if( doRunFeatArg.isSet() ) \
      { \
      doRunFeat = doRunFeatArg.getValue(); \
      } \
    if( doGradientArg.isSet() ) \
      { \
      doGradient = doGradientArg.getValue(); \
      } \
    if( doShapeFeatArg.isSet() ) \
      { \
      doShapeFeat = doShapeFeatArg.getValue(); \
      } \
    if( doHistoPlotArg.isSet() ) \
      { \
      doHistoPlot = doHistoPlotArg.getValue(); \
      } \
    if( parametersSerializeArg.isSet() ) \
      { \
      parametersSerialize = parametersSerializeArg.getValue(); \
      } \
    if( parametersDeSerializeArg.isSet() ) \
      { \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      } \
    if( echoSwitchArg.isSet() ) \
      { \
      echoSwitch = echoSwitchArg.getValue(); \
      } \
    if( xmlSwitchArg.isSet() ) \
      { \
      xmlSwitch = xmlSwitchArg.getValue(); \
      } \
    if( processInformationAddressStringArg.isSet() ) \
      { \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      } \
    if( returnParameterFileArg.isSet() ) \
      { \
      returnParameterFile = returnParameterFileArg.getValue(); \
      } \

#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    inputVolume: " << inputVolume << std::endl; \
std::cout << "    inputLabel: " << inputLabel << std::endl; \
std::cout << "    spath: " << spath << std::endl; \
std::cout << "    doNormalization: " << doNormalization << std::endl; \
std::cout << "    doHistogramFeat: " << doHistogramFeat << std::endl; \
std::cout << "    doPercentiles: " << doPercentiles << std::endl; \
std::cout << "    doCoocurrenceFeat: " << doCoocurrenceFeat << std::endl; \
std::cout << "    doRunFeat: " << doRunFeat << std::endl; \
std::cout << "    doGradient: " << doGradient << std::endl; \
std::cout << "    doShapeFeat: " << doShapeFeat << std::endl; \
std::cout << "    doHistoPlot: " << doHistoPlot << std::endl; \
std::cout << "    parametersSerialize: " << parametersSerialize << std::endl; \
std::cout << "    parametersDeSerialize: " << parametersDeSerialize << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_DECLARE;GENERATE_DESERIALIZATION;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;GENERATE_SERIALIZATION;
